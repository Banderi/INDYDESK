extends Node

func debug_tools_enabled():
	return false

func round_vector(vector):
	vector.x = round(vector.x)
	vector.y = round(vector.y)
	return vector
func signed_u16(v):
	return -1 if v == 65535 else v

# Palettes
const PALETTE_INDY = [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xD7, 0x00,
	0x00, 0x00, 0xB3, 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x43, 0x00,
	0xFB, 0xFB, 0xFB, 0x00, 0xE3, 0xE3, 0xE3, 0x00, 0xD3, 0xD3, 0xD3, 0x00, 0xC3, 0xC3, 0xC3, 0x00,
	0xB3, 0xB3, 0xB3, 0x00, 0xAB, 0xAB, 0xAB, 0x00, 0x9B, 0x9B, 0x9B, 0x00, 0x8B, 0x8B, 0x8B, 0x00,
	0x7B, 0x7B, 0x7B, 0x00, 0x73, 0x73, 0x73, 0x00, 0x63, 0x63, 0x63, 0x00, 0x53, 0x53, 0x53, 0x00,
	0x4B, 0x4B, 0x4B, 0x00, 0x3B, 0x3B, 0x3B, 0x00, 0x2B, 0x2B, 0x2B, 0x00, 0x23, 0x23, 0x23, 0x00,
	0x00, 0xC7, 0x43, 0x00, 0x00, 0xB7, 0x3F, 0x00, 0x00, 0xAB, 0x3F, 0x00, 0x00, 0x9F, 0x3B, 0x00,
	0x00, 0x93, 0x37, 0x00, 0x00, 0x87, 0x33, 0x00, 0x00, 0x7B, 0x33, 0x00, 0x00, 0x6F, 0x2F, 0x00,
	0x00, 0x63, 0x2B, 0x00, 0x00, 0x53, 0x23, 0x00, 0x00, 0x47, 0x1F, 0x00, 0x00, 0x37, 0x17, 0x00,
	0x00, 0x27, 0x0F, 0x00, 0x00, 0x1B, 0x0B, 0x00, 0x00, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3B, 0xFB, 0x7B, 0x00, 0x6B, 0x7B, 0xC3, 0x00, 0x5B, 0x53, 0xAB, 0x00, 0x53, 0x43, 0x93, 0x00,
	0x53, 0x2B, 0x7B, 0x00, 0x4B, 0x1B, 0x63, 0x00, 0x3B, 0x13, 0x3B, 0x00, 0xAB, 0xD7, 0xFF, 0x00,
	0x8F, 0xC3, 0xF3, 0x00, 0x73, 0xB3, 0xE7, 0x00, 0x5B, 0xA3, 0xDB, 0x00, 0x43, 0x97, 0xCF, 0x00,
	0x2F, 0x8B, 0xC3, 0x00, 0x1B, 0x7F, 0xB7, 0x00, 0x0B, 0x73, 0xAF, 0x00, 0x00, 0x6B, 0xA3, 0x00,
	0xEB, 0xFF, 0xFF, 0x00, 0xD7, 0xF3, 0xF3, 0x00, 0xC7, 0xE7, 0xE7, 0x00, 0xB7, 0xDB, 0xDB, 0x00,
	0xA3, 0xCF, 0xCF, 0x00, 0x97, 0xC3, 0xC3, 0x00, 0x7F, 0xB3, 0xB3, 0x00, 0x63, 0xA3, 0xA3, 0x00,
	0x4F, 0x93, 0x93, 0x00, 0x3B, 0x83, 0x83, 0x00, 0x2B, 0x73, 0x73, 0x00, 0x1B, 0x5F, 0x5F, 0x00,
	0x0F, 0x4F, 0x4F, 0x00, 0x07, 0x3F, 0x3F, 0x00, 0x00, 0x2F, 0x2F, 0x00, 0x00, 0x1F, 0x1F, 0x00,
	0x5B, 0xFB, 0xD3, 0x00, 0x43, 0xFB, 0xC3, 0x00, 0x23, 0xFB, 0xB3, 0x00, 0x00, 0xFB, 0xA3, 0x00,
	0x00, 0xE3, 0x93, 0x00, 0x00, 0xCB, 0x83, 0x00, 0x00, 0xB3, 0x73, 0x00, 0x00, 0x9B, 0x63, 0x00,
	0x00, 0x5B, 0x8B, 0x00, 0x00, 0x4F, 0x77, 0x00, 0x00, 0x43, 0x67, 0x00, 0x00, 0x37, 0x57, 0x00,
	0x00, 0x2F, 0x47, 0x00, 0x00, 0x23, 0x37, 0x00, 0x00, 0x17, 0x27, 0x00, 0x00, 0x0F, 0x17, 0x00,
	0x00, 0xFB, 0x4F, 0x00, 0x00, 0xEF, 0x4B, 0x00, 0x00, 0xDF, 0x47, 0x00, 0x00, 0xD3, 0x47, 0x00,
	0x00, 0x9F, 0x67, 0x00, 0x00, 0x7F, 0x5B, 0x00, 0x00, 0x63, 0x43, 0x00, 0x00, 0x47, 0x27, 0x00,
	0x00, 0x2B, 0x1B, 0x00, 0x23, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x37, 0xDB, 0x00, 0x77, 0x2B, 0xB3, 0x00,
	0xFB, 0xFB, 0xDB, 0x00, 0xFB, 0xFB, 0xBB, 0x00, 0xFB, 0xFB, 0x9B, 0x00, 0xFB, 0xFB, 0x7B, 0x00,
	0xFB, 0xFB, 0x5B, 0x00, 0xFB, 0xFB, 0x43, 0x00, 0xFB, 0xFB, 0x23, 0x00, 0xFB, 0xFB, 0x00, 0x00,
	0xE3, 0xE3, 0x00, 0x00, 0xCB, 0xCB, 0x00, 0x00, 0xB3, 0xB3, 0x00, 0x00, 0x9B, 0x9B, 0x00, 0x00,
	0x83, 0x83, 0x00, 0x00, 0x73, 0x73, 0x00, 0x00, 0x5B, 0x5B, 0x00, 0x00, 0x43, 0x43, 0x00, 0x00,
	0xFF, 0xBF, 0x47, 0x00, 0xF7, 0xAF, 0x33, 0x00, 0xEF, 0xA3, 0x1F, 0x00, 0xE7, 0x97, 0x0F, 0x00,
	0xE3, 0x8B, 0x00, 0x00, 0xCB, 0x7B, 0x00, 0x00, 0xB3, 0x6B, 0x00, 0x00, 0x9B, 0x5B, 0x00, 0x00,
	0x7B, 0x47, 0x00, 0x00, 0x5F, 0x37, 0x00, 0x00, 0x43, 0x27, 0x00, 0x00, 0x27, 0x17, 0x00, 0x00,
	0xFB, 0x63, 0x5B, 0x00, 0xFB, 0x43, 0x43, 0x00, 0xFB, 0x23, 0x23, 0x00, 0xFB, 0x00, 0x00, 0x00,
	0xFB, 0x00, 0x00, 0x00, 0xDB, 0x00, 0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0x00,
	0x8B, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00,
	0xBF, 0xBB, 0xFB, 0x00, 0xAF, 0xAB, 0xF7, 0x00, 0xA3, 0x9B, 0xF3, 0x00, 0x97, 0x8F, 0xEF, 0x00,
	0x87, 0x7F, 0xEB, 0x00, 0x7F, 0x73, 0xE7, 0x00, 0x6B, 0x5B, 0xDF, 0x00, 0x47, 0x3B, 0xCB, 0x00,
	0xF7, 0xB3, 0x43, 0x00, 0xF7, 0xBB, 0x4F, 0x00, 0xF7, 0xC7, 0x5B, 0x00, 0xF7, 0xCF, 0x6B, 0x00,
	0xF7, 0xD7, 0x77, 0x00, 0xF7, 0xDF, 0x83, 0x00, 0xF7, 0xE7, 0x93, 0x00, 0xF7, 0xCF, 0x6B, 0x00,
	0x00, 0x43, 0xCB, 0x00, 0x00, 0x33, 0xBB, 0x00, 0x00, 0x23, 0xA3, 0x00, 0x00, 0x1B, 0x93, 0x00,
	0x00, 0x0B, 0x7B, 0x00, 0x00, 0x00, 0x6B, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x43, 0x00,
	0x00, 0xFF, 0xFF, 0x00, 0x00, 0xE3, 0xF7, 0x00, 0x00, 0xCF, 0xF3, 0x00, 0x00, 0xB7, 0xEF, 0x00,
	0x00, 0xA3, 0xEB, 0x00, 0x00, 0x8B, 0xE7, 0x00, 0x00, 0x77, 0xDF, 0x00, 0x00, 0x63, 0xDB, 0x00,
	0x00, 0x4F, 0xD7, 0x00, 0x00, 0x3F, 0xD3, 0x00, 0x00, 0x2F, 0xCF, 0x00, 0x77, 0xC7, 0xE3, 0x00,
	0x6B, 0xB7, 0xDB, 0x00, 0x63, 0xA7, 0xD3, 0x00, 0x5B, 0x97, 0xCB, 0x00, 0x53, 0x8B, 0xC3, 0x00,
	0xDB, 0xEB, 0xFB, 0x00, 0xD3, 0xE3, 0xFB, 0x00, 0xC3, 0xDB, 0xFB, 0x00, 0xBB, 0xD3, 0xFB, 0x00,
	0xB3, 0xCB, 0xFB, 0x00, 0xA3, 0xC3, 0xFB, 0x00, 0x9B, 0xBB, 0xFB, 0x00, 0x8F, 0xB7, 0xFB, 0x00,
	0x83, 0xB3, 0xFB, 0x00, 0x73, 0xA3, 0xFB, 0x00, 0x63, 0x9B, 0xFB, 0x00, 0x5B, 0x93, 0xF3, 0x00,
	0x5B, 0x8B, 0xEB, 0x00, 0x53, 0x8B, 0xDB, 0x00, 0x53, 0x83, 0xD3, 0x00, 0x4B, 0x7B, 0xCB, 0x00,
	0x4B, 0x7B, 0xBB, 0x00, 0x43, 0x73, 0xB3, 0x00, 0x43, 0x6B, 0xAB, 0x00, 0x3B, 0x63, 0xA3, 0x00,
	0x3B, 0x63, 0x9B, 0x00, 0x33, 0x5B, 0x93, 0x00, 0x33, 0x5B, 0x8B, 0x00, 0x2B, 0x53, 0x83, 0x00,
	0x2B, 0x4B, 0x73, 0x00, 0x23, 0x4B, 0x6B, 0x00, 0x23, 0x43, 0x5B, 0x00, 0x1B, 0x3B, 0x53, 0x00,
	0x1B, 0x3B, 0x4B, 0x00, 0x1B, 0x33, 0x43, 0x00, 0x13, 0x2B, 0x3B, 0x00, 0x0B, 0x23, 0x2B, 0x00,
	0x00, 0xAB, 0x6F, 0x00, 0x00, 0xA3, 0x6B, 0x00, 0x00, 0x9F, 0x67, 0x00, 0x00, 0xA3, 0x6B, 0x00,
	0x00, 0xAB, 0x6F, 0x00, 0xE7, 0x93, 0x07, 0x00, 0xE7, 0x97, 0x0F, 0x00, 0xEB, 0x9F, 0x17, 0x00,
	0xEF, 0xA3, 0x23, 0x00, 0xF3, 0xAB, 0x2B, 0x00, 0xF7, 0xB3, 0x37, 0x00, 0xEF, 0xA7, 0x27, 0x00,
	0xEB, 0x9F, 0x1B, 0x00, 0xE7, 0x97, 0x0F, 0x00, 0x0B, 0xCB, 0xFB, 0x00, 0x0B, 0xA3, 0xFB, 0x00,
	0x0B, 0x73, 0xFB, 0x00, 0x0B, 0x4B, 0xFB, 0x00, 0x0B, 0x23, 0xFB, 0x00, 0x0B, 0x73, 0xFB, 0x00,
	0x00, 0x13, 0x93, 0x00, 0x00, 0x0B, 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00]
const PALETTE_YODA = [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x8B, 0x00, 0xC3, 0xCF, 0x4B, 0x00, 
	0x8B, 0xA3, 0x1B, 0x00, 0x57, 0x77, 0x00, 0x00, 0x8B, 0xA3, 0x1B, 0x00, 0xC3, 0xCF, 0x4B, 0x00, 
	0xFB, 0xFB, 0xFB, 0x00, 0xEB, 0xE7, 0xE7, 0x00, 0xDB, 0xD3, 0xD3, 0x00, 0xCB, 0xC3, 0xC3, 0x00, 
	0xBB, 0xB3, 0xB3, 0x00, 0xAB, 0xA3, 0xA3, 0x00, 0x9B, 0x8F, 0x8F, 0x00, 0x8B, 0x7F, 0x7F, 0x00, 
	0x7B, 0x6F, 0x6F, 0x00, 0x67, 0x5B, 0x5B, 0x00, 0x57, 0x4B, 0x4B, 0x00, 0x47, 0x3B, 0x3B, 0x00, 
	0x33, 0x2B, 0x2B, 0x00, 0x23, 0x1B, 0x1B, 0x00, 0x13, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xC7, 0x43, 0x00, 0x00, 0xB7, 0x43, 0x00, 0x00, 0xAB, 0x3F, 0x00, 0x00, 0x9F, 0x3F, 0x00, 
	0x00, 0x93, 0x3F, 0x00, 0x00, 0x87, 0x3B, 0x00, 0x00, 0x7B, 0x37, 0x00, 0x00, 0x6F, 0x33, 0x00, 
	0x00, 0x63, 0x33, 0x00, 0x00, 0x53, 0x2B, 0x00, 0x00, 0x47, 0x27, 0x00, 0x00, 0x3B, 0x23, 0x00, 
	0x00, 0x2F, 0x1B, 0x00, 0x00, 0x23, 0x13, 0x00, 0x00, 0x17, 0x0F, 0x00, 0x00, 0x0B, 0x07, 0x00, 
	0x4B, 0x7B, 0xBB, 0x00, 0x43, 0x73, 0xB3, 0x00, 0x43, 0x6B, 0xAB, 0x00, 0x3B, 0x63, 0xA3, 0x00, 
	0x3B, 0x63, 0x9B, 0x00, 0x33, 0x5B, 0x93, 0x00, 0x33, 0x5B, 0x8B, 0x00, 0x2B, 0x53, 0x83, 0x00, 
	0x2B, 0x4B, 0x73, 0x00, 0x23, 0x4B, 0x6B, 0x00, 0x23, 0x43, 0x5F, 0x00, 0x1B, 0x3B, 0x53, 0x00, 
	0x1B, 0x37, 0x47, 0x00, 0x1B, 0x33, 0x43, 0x00, 0x13, 0x2B, 0x3B, 0x00, 0x0B, 0x23, 0x2B, 0x00, 
	0xD7, 0xFF, 0xFF, 0x00, 0xBB, 0xEF, 0xEF, 0x00, 0xA3, 0xDF, 0xDF, 0x00, 0x8B, 0xCF, 0xCF, 0x00, 
	0x77, 0xC3, 0xC3, 0x00, 0x63, 0xB3, 0xB3, 0x00, 0x53, 0xA3, 0xA3, 0x00, 0x43, 0x93, 0x93, 0x00, 
	0x33, 0x87, 0x87, 0x00, 0x27, 0x77, 0x77, 0x00, 0x1B, 0x67, 0x67, 0x00, 0x13, 0x5B, 0x5B, 0x00, 
	0x0B, 0x4B, 0x4B, 0x00, 0x07, 0x3B, 0x3B, 0x00, 0x00, 0x2B, 0x2B, 0x00, 0x00, 0x1F, 0x1F, 0x00, 
	0xDB, 0xEB, 0xFB, 0x00, 0xD3, 0xE3, 0xFB, 0x00, 0xC3, 0xDB, 0xFB, 0x00, 0xBB, 0xD3, 0xFB, 0x00, 
	0xB3, 0xCB, 0xFB, 0x00, 0xA3, 0xC3, 0xFB, 0x00, 0x9B, 0xBB, 0xFB, 0x00, 0x8F, 0xB7, 0xFB, 0x00, 
	0x83, 0xB3, 0xF7, 0x00, 0x73, 0xA7, 0xFB, 0x00, 0x63, 0x9B, 0xFB, 0x00, 0x5B, 0x93, 0xF3, 0x00, 
	0x5B, 0x8B, 0xEB, 0x00, 0x53, 0x8B, 0xDB, 0x00, 0x53, 0x83, 0xD3, 0x00, 0x4B, 0x7B, 0xCB, 0x00, 
	0x9B, 0xC7, 0xFF, 0x00, 0x8F, 0xB7, 0xF7, 0x00, 0x87, 0xB3, 0xEF, 0x00, 0x7F, 0xA7, 0xF3, 0x00, 
	0x73, 0x9F, 0xEF, 0x00, 0x53, 0x83, 0xCF, 0x00, 0x3B, 0x6B, 0xB3, 0x00, 0x2F, 0x5B, 0xA3, 0x00, 
	0x23, 0x4F, 0x93, 0x00, 0x1B, 0x43, 0x83, 0x00, 0x13, 0x3B, 0x77, 0x00, 0x0B, 0x2F, 0x67, 0x00, 
	0x07, 0x27, 0x57, 0x00, 0x00, 0x1B, 0x47, 0x00, 0x00, 0x13, 0x37, 0x00, 0x00, 0x0F, 0x2B, 0x00, 
	0xFB, 0xFB, 0xE7, 0x00, 0xF3, 0xF3, 0xD3, 0x00, 0xEB, 0xE7, 0xC7, 0x00, 0xE3, 0xDF, 0xB7, 0x00, 
	0xDB, 0xD7, 0xA7, 0x00, 0xD3, 0xCF, 0x97, 0x00, 0xCB, 0xC7, 0x8B, 0x00, 0xC3, 0xBB, 0x7F, 0x00, 
	0xBB, 0xB3, 0x73, 0x00, 0xAF, 0xA7, 0x63, 0x00, 0x9B, 0x93, 0x47, 0x00, 0x87, 0x7B, 0x33, 0x00, 
	0x6F, 0x67, 0x1F, 0x00, 0x5B, 0x53, 0x0F, 0x00, 0x47, 0x43, 0x00, 0x00, 0x37, 0x33, 0x00, 0x00, 
	0xFF, 0xF7, 0xF7, 0x00, 0xEF, 0xDF, 0xDF, 0x00, 0xDF, 0xC7, 0xC7, 0x00, 0xCF, 0xB3, 0xB3, 0x00, 
	0xBF, 0x9F, 0x9F, 0x00, 0xB3, 0x8B, 0x8B, 0x00, 0xA3, 0x7B, 0x7B, 0x00, 0x93, 0x6B, 0x6B, 0x00, 
	0x83, 0x57, 0x57, 0x00, 0x73, 0x4B, 0x4B, 0x00, 0x67, 0x3B, 0x3B, 0x00, 0x57, 0x2F, 0x2F, 0x00, 
	0x47, 0x27, 0x27, 0x00, 0x37, 0x1B, 0x1B, 0x00, 0x27, 0x13, 0x13, 0x00, 0x1B, 0x0B, 0x0B, 0x00, 
	0xF7, 0xB3, 0x37, 0x00, 0xE7, 0x93, 0x07, 0x00, 0xFB, 0x53, 0x0B, 0x00, 0xFB, 0x00, 0x00, 0x00, 
	0xCB, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 
	0xBF, 0xBB, 0xFB, 0x00, 0x8F, 0x8B, 0xFB, 0x00, 0x5F, 0x5B, 0xFB, 0x00, 0x93, 0xBB, 0xFF, 0x00, 
	0x5F, 0x97, 0xF7, 0x00, 0x3B, 0x7B, 0xEF, 0x00, 0x23, 0x63, 0xC3, 0x00, 0x13, 0x53, 0xB3, 0x00, 
	0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xD3, 0x00, 
	0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 0xB7, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 0x9B, 0x00, 
	0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x63, 0x00, 
	0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x2B, 0x00, 
	0x00, 0xFF, 0xFF, 0x00, 0x00, 0xE3, 0xF7, 0x00, 0x00, 0xCF, 0xF3, 0x00, 0x00, 0xB7, 0xEF, 0x00, 
	0x00, 0xA3, 0xEB, 0x00, 0x00, 0x8B, 0xE7, 0x00, 0x00, 0x77, 0xDF, 0x00, 0x00, 0x63, 0xDB, 0x00, 
	0x00, 0x4F, 0xD7, 0x00, 0x00, 0x3F, 0xD3, 0x00, 0x00, 0x2F, 0xCF, 0x00, 0x97, 0xFF, 0xFF, 0x00, 
	0x83, 0xDF, 0xEF, 0x00, 0x73, 0xC3, 0xDF, 0x00, 0x5F, 0xA7, 0xCF, 0x00, 0x53, 0x8B, 0xC3, 0x00, 
	0x2B, 0x2B, 0x00, 0x00, 0x23, 0x23, 0x00, 0x00, 0x1B, 0x1B, 0x00, 0x00, 0x13, 0x13, 0x00, 0x00, 
	0xFF, 0x0B, 0x00, 0x00, 0xFF, 0x00, 0x4B, 0x00, 0xFF, 0x00, 0xA3, 0x00, 0xFF, 0x00, 0xFF, 0x00, 
	0x00, 0xFF, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x33, 0x2F, 0x00, 
	0x00, 0x00, 0xFF, 0x00, 0x00, 0x1F, 0x97, 0x00, 0xDF, 0x00, 0xFF, 0x00, 0x73, 0x00, 0x77, 0x00, 
	0x6B, 0x7B, 0xC3, 0x00, 0x57, 0x57, 0xAB, 0x00, 0x57, 0x47, 0x93, 0x00, 0x53, 0x37, 0x7F, 0x00, 
	0x4F, 0x27, 0x67, 0x00, 0x47, 0x1B, 0x4F, 0x00, 0x3B, 0x13, 0x3B, 0x00, 0x27, 0x77, 0x77, 0x00, 
	0x23, 0x73, 0x73, 0x00, 0x1F, 0x6F, 0x6F, 0x00, 0x1B, 0x6B, 0x6B, 0x00, 0x1B, 0x67, 0x67, 0x00, 
	0x1B, 0x6B, 0x6B, 0x00, 0x1F, 0x6F, 0x6F, 0x00, 0x23, 0x73, 0x73, 0x00, 0x27, 0x77, 0x77, 0x00, 
	0xFF, 0xFF, 0xEF, 0x00, 0xF7, 0xF7, 0xDB, 0x00, 0xF3, 0xEF, 0xCB, 0x00, 0xEF, 0xEB, 0xBB, 0x00, 
	0xF3, 0xEF, 0xCB, 0x00, 0xE7, 0x93, 0x07, 0x00, 0xE7, 0x97, 0x0F, 0x00, 0xEB, 0x9F, 0x17, 0x00, 
	0xEF, 0xA3, 0x23, 0x00, 0xF3, 0xAB, 0x2B, 0x00, 0xF7, 0xB3, 0x37, 0x00, 0xEF, 0xA7, 0x27, 0x00, 
	0xEB, 0x9F, 0x1B, 0x00, 0xE7, 0x97, 0x0F, 0x00, 0x0B, 0xCB, 0xFB, 0x00, 0x0B, 0xA3, 0xFB, 0x00, 
	0x0B, 0x73, 0xFB, 0x00, 0x0B, 0x4B, 0xFB, 0x00, 0x0B, 0x23, 0xFB, 0x00, 0x0B, 0x73, 0xFB, 0x00, 
	0x00, 0x13, 0x93, 0x00, 0x00, 0x0B, 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00]

# Game enums
enum Zones {
	None = 0
	Empty = 1
	Blockade_North = 2
	Blockade_South = 3
	Blockade_East = 4
	Blockade_West = 5
	TravelStart = 6
	TravelEnd = 7
	Room = 8
	Load = 9
	Goal = 10
	Town = 11
	UNUSED12 = 12
	Win = 13
	Lose = 14
	Trade = 15
	Use = 16
	Find = 17
	Find_Weapon = 18}
enum Hotspots {
	drop_quest_item = 0
	spawn_location = 1
	drop_unique_weapon = 2
	vehicle_to = 3
	vehicle_back = 4
	drop_map = 5
	drop_item = 6
	npc = 7
	drop_weapon = 8
	door_in = 9
	door_out = 10
	UNUSED11 = 11
	lock = 12
	teleporter = 13
	ship_to_planet = 14
	ship_from_planet = 15}
enum TileFlags {
	has_transparency = 1 << 0
	is_floor = 1 << 1
	is_obstacle = 1 << 2
	is_draggable = 1 << 3
	is_roof = 1 << 4
	is_locator = 1 << 5
	is_weapon = 1 << 6
	is_item = 1 << 7
	is_character = 1 << 8
	UNK9 = 1 << 9
	UNK10 = 1 << 10
	UNK11 = 1 << 11
	UNK12 = 1 << 12
	UNK13 = 1 << 13
	UNK14 = 1 << 14
	UNK15 = 1 << 15
	
	# floors
	is_doorway = 1 << 16					# stairs, hutdoor, hutstairs, bridge, rivercrossing, walldoor, pyramidstairs_left&right
	
	# characters
	is_hero = 1 << 16						# indy
	is_enemy = 1 << 17						# npc493-508 (monsters)
	is_npc = 1 << 18						# npc92, npc154, alien, npc229, npc458-462, npc484-492, indyleft
	
	# tiles / map
	is_empty = 1 << 16
	is_town = 1 << 17
	is_unsolved_puzzle = 1 << 18
	is_solved_puzzle = 1 << 19
	is_unsolved_travel = 1 << 20
	is_solved_travel = 1 << 21
	is_unsolved_blockade_north = 1 << 22
	is_unsolved_blockade_south = 1 << 23
	is_unsolved_blockade_west = 1 << 24
	is_unsolved_blockade_east = 1 << 25
	is_solved_blockade_north = 1 << 26
	is_solved_blockade_south = 1 << 27
	is_solved_blockade_west = 1 << 28
	is_solved_blockade_east = 1 << 29
	is_end_zone = 1 << 30
	is_location_indicator = 1 << 31
	
	# items
	is_keycard = 1 << 16					# key
	is_tool = 1 << 17						# dynamite, bucket, shovel, spear, gasoline
	is_part = 1 << 18						# gearwheel, shield?, woodplanks
	is_valuable = 1 << 19					# treasuremap, coins, aztec71, bluesnake, aztecwheel, aztecmask, bluemask, bluedagger, jadeidol, skull, birdhead, sallet, stonetablet, obspear, skull2
	is_map = 1 << 20
	is_harmful = 1 << 21					# tequila
	is_edible = 1 << 22						# yerba_buena, medikit, bananas
	
	# weapons
	is_luger = 1 << 16						# luger, bullet
	is_arrow = 1 << 17
	is_machete = 1 << 18
	is_whip = 1 << 19}
enum CharacterType {
	hero = 1
	enemy = 2
	weapon = 4}
enum MovementType {
	none = 0
	sit = 4
	wander = 9
	patrol = 10
	animation = 12}
func value_list_flags(value, enums):
	var flags = []
	var enum_names = enums.keys()
	for enm in enum_names:
		var e = enums[enm]
		if value & e:
			flags.push_back(enm)
	return flags

# Game data loading
var DATA = {
	"sounds": [],
	"tiles": [],
	"zones": [],
	"puzzles": [],
	"characters": {},
	"actions": {}
}
func assert_marker(marker):
	assert(DAW.get_buffer(4).get_string_from_ascii() == marker)

var DAW = DataFile.new()
func load_daw(file_path):
	var r = DAW.open(file_path, File.READ)
	if r != OK:
		Log.error(null,r,"could not load DAW file!")
	
	DAW.seek(4)
	DATA["VERS"] = DAW.get_32()
	Log.generic(null,"'VERS' at 0x00000000: %d" % [DATA["VERS"]])
	
	while !DAW.end_reached():
		var offset = DAW.get_position()
		var s_name = DataStruct.as_text(DAW.read("str4"))
		var s_size = DAW.get_32()
		var end_of_section = DAW.get_position() + s_size
		Log.generic(null,"'%s' at 0x%08X: %d bytes" % [s_name, offset, s_size])
		match s_name:
			"STUP":
				DAW.get_buffer(s_size)
			"SNDS": # sound files names
				var _unk_num = DAW.get_16()
				while DAW.get_position() < end_of_section:
					var subs_size = DAW.get_16()
					DATA.sounds.push_back(DAW.get_buffer(subs_size).get_string_from_ascii())
			"TILE": # tile bitmaps
				while DAW.get_position() < end_of_section:
					DATA.tiles.push_back({
						"name": "",
						"flags": DAW.get_32(),
						"bmp": DAW.get_buffer(1024)
					})
			"ZONE": # zones data
				for i in DAW.get_16():
					assert_marker("IZON")
					var _subs_size = DAW.get_32()
					var z_width = DAW.get_16()
					var z_height = DAW.get_16()
					var z_type = DAW.get_32()
					var z_total_tiles = z_width * z_height
					var z_tiles = []
					for _t in z_total_tiles:
						z_tiles.push_back({
							"x": signed_u16(DAW.get_16()),
							"y": signed_u16(DAW.get_16()),
							"z": signed_u16(DAW.get_16()),
						})
					DATA.zones.push_back({
						"name": "",
						"width": z_width,
						"height": z_height,
						"type": z_type,
						"tiles": z_tiles,
						
						"unkn_zaux": null,
						"monsters": [],
						"items": [],
						
						"reward_items": [],
						"npcs": [],
						"izx4": [],
						
						"hotspots": [],
						"puzzle": -1,
					})
					if DAW.get_position() > end_of_section:
						break
			"ZAUX": # monsters, required items
				for i in DATA.zones.size():
					assert_marker("IZAX")
					var _subs_size = DAW.get_32()
					DATA.zones[i].unkn_zaux = DAW.get_16()
					for _i in DAW.get_16():
						DATA.zones[i].monsters.push_back({
							"id": DAW.get_16(),
							"x": signed_u16(DAW.get_16()),
							"y": signed_u16(DAW.get_16()),
						})
					for _i in DAW.get_16():
						DATA.zones[i].items.push_back(DAW.get_16())
			"ZAX2": # reward items
				for i in DATA.zones.size():
					assert_marker("IZX2")
					var _subs_size = DAW.get_32()
					for _i in DAW.get_16():
						DATA.zones[i].reward_items.push_back(DAW.get_16())
			"ZAX3": # npcs
				for i in DATA.zones.size():
					assert_marker("IZX3")
					var _subs_size = DAW.get_32()
					for _i in DAW.get_16():
						DATA.zones[i].npcs.push_back(DAW.get_16())
			"ZAX4": # ???
				for i in DATA.zones.size():
					assert_marker("IZX4")
					var subs_size = DAW.get_32()
					var subs_data = DAW.get_buffer(subs_size)
					DATA.zones[i].izx4.push_back(subs_data)
			"HTSP": # hotspots
				while DAW.get_position() < end_of_section:
					var zone_id = DAW.get_16()
					if zone_id == 65535:
						break
					for _i in DAW.get_16():
						DATA.zones[zone_id].hotspots.push_back({
							"type": DAW.get_32(),
							"x": DAW.get_16(),
							"y": DAW.get_16(),
							"enabled": DAW.get_16(),
							"args": DAW.get_16(),
						})
			"ACTN": # zone scripts?
				while DAW.get_position() < end_of_section:
					var action_group_id = DAW.get_16()
					if action_group_id == 65535:
						break
					var action_group = []
					for _a in DAW.get_16():
						assert_marker("IACT")
						var _subs_size = DAW.get_32()
						var action_data = {
							"name": "",
							"conditions": [],
							"instructions": [],
						}

						for _c in DAW.get_16(): # conditions
							var condition = {
								"opcode": DAW.get_16(),
								"args": [
									DAW.get_16(),
									DAW.get_16(),
									DAW.get_16(),
									DAW.get_16(),
									DAW.get_16(),
								],
							}
							var text_length = DAW.get_16()
							condition["text"] = DAW.get_buffer(text_length).get_string_from_ascii()
							action_data.conditions.push_back(condition)
						for _i in DAW.get_16(): # instructions
							var instruction = {
								"opcode": DAW.get_16(),
								"args": [
									DAW.get_16(),
									DAW.get_16(),
									DAW.get_16(),
									DAW.get_16(),
									DAW.get_16(),
								],
							}
							var text_length = DAW.get_16()
							instruction["text"] = DAW.get_buffer(text_length).get_string_from_ascii()
							action_data.instructions.push_back(instruction)
						action_group.push_back(action_data)
					DATA.actions[action_group_id] = action_group
				
			"PUZ2": # puzzles
				while DAW.get_position() < end_of_section:
					var zone_id = DAW.get_16()
					if zone_id == 65535:
						break
					assert_marker("IPUZ")
					var subs_size = DAW.get_32()
					DATA.puzzles.push_back({
						"name": "",
						"type": DAW.get_32(),
						"item1_class": DAW.get_32(),
						"item2_class": DAW.get_32(),
						"ipuz_strings": DAW.get_buffer(subs_size - 16).get_string_from_ascii(),
						"item1": DAW.get_16(),
						"item2": DAW.get_16()
					})
					DATA.zones[zone_id].puzzle = DATA.puzzles.size() - 1
			"CHAR": # characters
				while DAW.get_position() < end_of_section:
					var char_id = DAW.get_16()
					if char_id == 65535:
						break
					assert_marker("ICHA")
					var _subs_size = DAW.get_32()
					var c_name = DAW.get_buffer(16).get_string_from_ascii()
					var data = {
						"name": c_name,
						"type": DAW.get_16(),
						"movement_type": DAW.get_16(),
						"sprites1": [
							# DIRECTIONS (corner): NW NE SW SE
							# DIRECTIONS (side): S W N E
							DAW.get_16(),	# N ^
							DAW.get_16(),	# S v
							DAW.get_16(),	# N ^
							DAW.get_16(),	# W <
							DAW.get_16(),	# W <
							DAW.get_16(),	# N ^
							DAW.get_16(),	# E >
							DAW.get_16()	# E >
						],
						"sprites2": [
							# frame 1
							DAW.get_16(),	# N ^
							DAW.get_16(),	# S v
							DAW.get_16(),	# N ^
							DAW.get_16(),	# W <
							DAW.get_16(),	# W <
							DAW.get_16(),	# N ^
							DAW.get_16(),	# E >
							DAW.get_16(),	# E >
							
							# frame 2
							DAW.get_16(),	# N ^
							DAW.get_16(),	# S v
							DAW.get_16(),	# N ^
							DAW.get_16(),	# W <
							DAW.get_16(),	# W <
							DAW.get_16(),	# N ^
							DAW.get_16(),	# E >
							DAW.get_16(),	# E >
						],
						"sprites": HERO_SPRITESHEET if c_name == "HERO" else SpriteFrames.new(),
						
						"weapon_refid": null,
						"weapon_health": null,
						"damage": null,
					}
					for f in 8:
						data.sprites1[f] = signed_u16(data.sprites1[f])
					for f in 16:
						data.sprites2[f] = signed_u16(data.sprites2[f])
					DATA.characters[char_id] = data
			"CHWP": # weapons
				while DAW.get_position() < end_of_section:
					var char_id = DAW.get_16()
					if char_id == 65535:
						break
					DATA.characters[char_id].weapon_refid = DAW.get_16() # id of weapon "character" if monster, or id of attack sound if weapon
					DATA.characters[char_id].weapon_health = DAW.get_16()
			"CAUX": # characters damage
				while DAW.get_position() < end_of_section:
					var char_id = DAW.get_16()
					if char_id == 65535:
						break
					DATA.characters[char_id].damage = DAW.get_16()
			"TNAM": # tiles names
				while DAW.get_position() < end_of_section:
					var tile_id = DAW.get_16()
					if tile_id == 65535:
						break
					DATA.tiles[tile_id].name = DAW.get_buffer(16).get_string_from_ascii()
			"ZNAM": # zones names
				while DAW.get_position() < end_of_section:
					var zone_id = DAW.get_16()
					if zone_id == 65535:
						break
					DATA.zones[zone_id].name = DAW.get_buffer(16).get_string_from_ascii()
			"PNAM": # puzzles names
				var num_subs = DAW.get_16()
				for puzzle_id in num_subs:
					DATA.puzzles[puzzle_id].name = DAW.get_buffer(16).get_string_from_ascii()
					if DAW.get_position() > end_of_section:
						break
			"ANAM": # action scripts names?
				while DAW.get_position() < end_of_section:
					var action_group_id = DAW.get_16()
					if action_group_id == 65535:
						break
					while true:
						var _a = DAW.get_16()
						if _a == 65535:
							break
						DATA.actions[action_group_id][_a].name = DAW.get_buffer(16).get_string_from_ascii()
			"ENDF":
				assert(s_size == 0)
	Log.generic(null,"DAW file loaded sucessfully!")

# Textures
onready var IMAGE_BUFFER = Image.new()
func texture_from_data(data, width, height, palette):
	IMAGE_BUFFER.create(width, height, false, Image.FORMAT_RGBA8)
	IMAGE_BUFFER.lock()
	for y in height:
		for x in width:
			var pixel_index = y * width + x
			var pixel_raw = data[pixel_index]
			if pixel_raw == 0:
				IMAGE_BUFFER.set_pixel(x, y, Color(1,1,1,0))
			else:
				var r = float(palette[pixel_raw*4+2]) / 255.0
				var g = float(palette[pixel_raw*4+1]) / 255.0
				var b = float(palette[pixel_raw*4+0]) / 255.0
				IMAGE_BUFFER.set_pixel(x, y, Color(r,g,b,1))
	IMAGE_BUFFER.unlock()
	var texture = ImageTexture.new()
	texture.create_from_image(IMAGE_BUFFER)
	return texture
func save_texture(texture : ImageTexture, path):
	return texture.get_data().save_png(path)

# Sprites
onready var HERO_SPRITESHEET = SpriteFrames.new()
onready var ATTACK_SPRITESHEET = SpriteFrames.new()
func get_sprite(i):
	if i == -1:
		return
	return load("res://assets/indy/tile"+str(i)+".png")
func generate_tileset(tile_set : TileSet):
	tile_set.clear()
	for i in DATA.tiles.size():
		tile_set.create_tile(i)
		tile_set.tile_set_texture(i,get_sprite(i))
	Log.generic(null,"Tileset generated sucessfully!")
func sprite_add_anim(spritesheet : SpriteFrames, anim_name : String, frames_list : Array, frames : Array):
	if spritesheet.has_animation(anim_name):
		spritesheet.remove_animation(anim_name)
	spritesheet.add_animation(anim_name)
	spritesheet.set_animation_speed(anim_name, 7.0)
	for f in frames:
		spritesheet.add_frame(anim_name,get_sprite(frames_list[f]))
func sprite_add_4way_anim(spritesheet : SpriteFrames, anim_name : String, frames_list : Array, frames_N : Array, frames_S : Array, frames_W : Array, frames_E : Array):
	sprite_add_anim(spritesheet, str(anim_name,"_N"), frames_list, frames_N)
	sprite_add_anim(spritesheet, str(anim_name,"_S"), frames_list, frames_S)
	sprite_add_anim(spritesheet, str(anim_name,"_W"), frames_list, frames_W)
	sprite_add_anim(spritesheet, str(anim_name,"_E"), frames_list, frames_E)
func generate_spritesheets():
	for char_id in DATA.characters:
		var character = DATA.characters[char_id]
		var c_name = character.name
		var spritesheet = character.sprites
		match character.type:
			CharacterType.hero, CharacterType.enemy:
				sprite_add_4way_anim(spritesheet, "idle", character.sprites1, [0], [1], [3], [6])
				if character.sprites2[0] != -1:
					sprite_add_4way_anim(spritesheet, "walk", character.sprites2, [0,8], [1,9], [3,11], [6,14])
			CharacterType.weapon:
				if character.sprites1[7] != -1: # "inventory" sprite
					sprite_add_anim(spritesheet, "item", character.sprites1, [7])
				if character.sprites1[0] != -1:
					sprite_add_4way_anim(spritesheet, "projectile", character.sprites1, [0], [1], [3], [6])
				if character.sprites2[0] != -1:
					# fix for WhipWeapon missing sprite:
					if c_name == "WhipWeapon":
						character.sprites2[2] = 480
					sprite_add_4way_anim(HERO_SPRITESHEET, c_name, character.sprites2, [0,8,0], [1,9,1], [3,11,3], [6,14,6])
					sprite_add_4way_anim(ATTACK_SPRITESHEET, c_name, character.sprites2, [2,10,2], [4,12,4], [5,13,5], [7,15,7])
	Log.generic(null,"Character spritesheets generated successfully!")

# Tiles
func to_tile(vector, rounded = true):
	var tile = (vector - Vector2(16,16)) / 32.0
	if rounded:
		tile = round_vector(tile)
	return tile
func to_vector(tile):
	return (tile * 32.0) + Vector2(16,16)
var FLOOR_TILES : TileMap = null
var WALL_TILES : TileMap = null
var ROOF_TILES : TileMap = null
func get_tile_data(tile_id):
	return DATA.tiles[tile_id]
func clear_zone():
	FLOOR_TILES.clear()
	WALL_TILES.clear()
	ROOF_TILES.clear()
	for obj in get_tree().get_nodes_in_group("objects"):
		obj.queue_free()
func load_zone(id, map_origin = Vector2(), clear = true):
	if clear:
		clear_zone()
	var zone_data = DATA.zones[id]
	for y in zone_data.height:
		for x in zone_data.width:
			var tile_layers = zone_data.tiles[y * zone_data.width + x]
			var world_tile_coords = Vector2(x, y) + map_origin
			
			# for object (wall) tiles, only set the tilemap for non-moveable walls
			var tile = tile_layers.y
			if tile != -1 && get_tile_data(tile).flags & TileFlags.is_draggable:
				spawn_object(tile, x, y)
			else:
				WALL_TILES.set_cellv(world_tile_coords, tile_layers.y)
			
			# for floor and roof (ceiling) tiles, go ahead
			FLOOR_TILES.set_cellv(world_tile_coords, tile_layers.x)
			ROOF_TILES.set_cellv(world_tile_coords, tile_layers.z)
	Log.generic(null,"Loaded: zone %d"%[id])
	return zone_data
func is_tile_obstructed(tile):
	var flood_id = FLOOR_TILES.get_cellv(tile)
	if flood_id == -1:
		return true
	var wall_id = WALL_TILES.get_cellv(tile)
	if wall_id != -1:
		return true
	if get_object_at(tile) != null:
		return true
	return false
func get_object_at(tile):
	for obj in get_tree().get_nodes_in_group("objects"):
		if to_tile(obj.position) == tile:
			return obj
	return null
func set_tile_at(zone_id, tile, level, tile_id):
	# TODO
#	var zone_data = DATA.zones[zone_id]
#	var tile_layers = zone_data.tiles[tile.y * zone_data.width + tile.x]
#	tile_layers[level] = tile_id
	pass

# Objects, actors
onready var OBJECT_SCN = load("res://scenes/Object.tscn")
func spawn_object(tile_id, x, y):
	var obj = OBJECT_SCN.instance()
	obj.texture = get_sprite(tile_id)
	obj.position = to_vector(Vector2(x,y))
	obj.tile_id = tile_id
	WALL_TILES.add_child(obj)
func spawn_monster(char_id, x, y):
	pass
